package logic

import (
	"context"
	"crypto/rsa"
	"encoding/json"
	"fmt"
	jwtgo "github.com/dgrijalva/jwt-go"
	goa "goa.design/goa/v3/pkg"
	"log"
	"math"
	"math/big"
	"time"

	gen_math "github.com/sgerogia/hello-goa/gen/math"
	"goa.design/goa/v3/security"
)

// math service  implementation.
type MathSrvc struct {
	logger *log.Logger
	Url           string
	PublicKey     *rsa.PublicKey
	JwtExpiryMins *int
}

// NewMath returns the math service implementation.
func NewMath(logger *log.Logger, url string, publicKey *rsa.PublicKey, jwtExpiry *int) gen_math.Service {
	return &MathSrvc{logger, url, publicKey, jwtExpiry}
}

// JWTAuth implements the authorization logic for service "math" for the "jwt"
// security scheme.
func (s *MathSrvc) JWTAuth(ctx context.Context, token string, scheme *security.JWTScheme) (context.Context, error) {

	claims := &Claims{}
	_, err := jwtgo.ParseWithClaims(token, claims, func(token *jwtgo.Token) (interface{}, error) {
		return s.PublicKey, nil
	})

	if err != nil {
		return ctx, goa.PermanentError("Unauthorized", "Invalid token")
	}

	// matching issuer
	if s.Url != claims.Issuer {
		return ctx, goa.PermanentError("Unauthorized", "Unexpected token issuer: %s", claims.Issuer)
	}

	// non-empty sub
	if claims.Subject == "" {
		return ctx, goa.PermanentError("Unauthorized", "Incorrect token subject: %s", claims.Subject)
	}

	// incorrect aud
	if claims.Audience != claims.Subject {
		return ctx, goa.PermanentError("Unauthorized", "Incorrect token audience: %s", claims.Audience)
	}

	exp := time.Unix(claims.ExpiresAt, 0)
	iat := time.Unix(claims.IssuedAt, 0)
	expiry := time.Duration(*s.JwtExpiryMins) * time.Minute
	// correct JWT "lifespan"
	if exp.Sub(iat) > expiry {
		return ctx, goa.PermanentError("Unauthorized", "Unexpected token expiry: %d", claims.ExpiresAt)
	}

	return ctx, nil
}

// Accepts an arbitrary document as payload and sums the numbers contained
// within.
// The document can contain a variety of things: arrays [1,2,3,4], objects
// {"a":1, "b":2, "c":3}, numbers, and strings.
// The endpoint should find all of the numbers throughout the document and add
// them together.

// For example:
// * [1,2,3,4] and {"a":6,"b":4} both have a auth_sum of 10.
// * [[[2]]] and {"a":{"b":4},"c":-2} both have a auth_sum of 2.
// * {"a":[-1,1,"dark"]} and [-1,{"a":1, "b":"light"}] both have a auth_sum of
// 0.
// * [] and {} both have a auth_sum of 0.

// Protected with a valid JWT token, generated by the /auth endpoint, provided
// as a Bearer Authorization header.
// The response is the sum of all numbers in the document.
func (s *MathSrvc) Sum(ctx context.Context, p *gen_math.SumPayload) (res string, err error) {

	// no token - sanity check!
	if p.Token == "" {
		return "", goa.PermanentError("Unauthorized", "Invalid token")
	}

	// empty body
	if p.Doc == "" {
		return "", goa.PermanentError("MalformedPayload", "Empty body")
	}

	var doc interface{}
	e := json.Unmarshal([]byte(p.Doc), &doc)

	// invalid JSON
	if e != nil {
		return "", goa.PermanentError("MalformedPayload", "Malformed JSON: %s", e.Error())
	}

	// process JSON
	sum := ProcessJson(doc)

	return fmt.Sprint(sum), nil
}

// Accepts a sequence of numbers and multiplies them.
// If any of the arguments is not a valid number, it returns an error.

// Protected with a valid JWT token, generated by the /auth endpoint, provided
// as a Bearer Authorization header.
// The response is the multiplication of all numbers.
func (s *MathSrvc) Mul(ctx context.Context, p *gen_math.MulPayload) (res string, err error) {

	// no token - sanity check!
	if p.Token == "" {
		return "", goa.PermanentError("Unauthorized", "Invalid token")
	}

	// empty args -> return 0
	if len(p.Numbers) == 0 {
		return "0", nil
	}

	total := new(big.Float)
	temp := new(big.Float)
	for index, ns := range p.Numbers {
		_, success := temp.SetString(ns)
		// if error, break
		if !success {
			return "", goa.PermanentError("MalformedPayload", "Malformed number: %s", ns)
		}
		if index == 0 {
			total.Set(temp)
		} else {
			total = total.Mul(total, temp)
		}
	}

	return fmt.Sprint(total), nil
}

// Recursive method to generate a sum from the numbers in an arbitrary JSON document
// The generated number is formatted as a string, either as an integer or with fixed 5 decimals precision
func ProcessJson(doc interface{}) string {

	var sum float64 = 0

	processEntry(doc, &sum)

	// depending if integer result, format string with or without decimals
	if sum == math.Trunc(sum) {
		return fmt.Sprintf("%v", sum)
	} else {
		return fmt.Sprintf("%.5f", sum)
	}
}

func processEntry(e interface{}, sum *float64) {

	switch e.(type) {
	case float64:
		*sum += e.(float64)
	case map[string]interface{}:
		for k, v := range e.(map[string]interface{}) {
			processEntry(k, sum)
			processEntry(v, sum)
		}
	case []interface{}:
		for _, i := range e.([]interface{}) {
			processEntry(i, sum)
		}
	default:
		// ignore
	}

}