package logic

import (
	"context"
	"encoding/json"
	"fmt"
	goa "goa.design/goa/v3/pkg"
	"log"
	"math"
	"math/big"

	gen_math "github.com/sgerogia/hello-goa/gen/math"
	"goa.design/goa/v3/security"
)

// math service example implementation.
// The example methods log the requests and return zero values.
type MathSrvc struct {
	logger *log.Logger
}

// NewMath returns the math service implementation.
func NewMath(logger *log.Logger) gen_math.Service {
	return &MathSrvc{logger}
}

// JWTAuth implements the authorization logic for service "math" for the "jwt"
// security scheme.
func (s *MathSrvc) JWTAuth(ctx context.Context, token string, scheme *security.JWTScheme) (context.Context, error) {
	//
	// TBD: add authorization logic.
	//
	// In case of authorization failure this function should return
	// one of the generated error structs, e.g.:
	//
	//    return ctx, myservice.MakeUnauthorizedError("invalid token")
	//
	// Alternatively this function may return an instance of
	// goa.ServiceError with a Name field value that matches one of
	// the design error names, e.g:
	//
	//    return ctx, goa.PermanentError("unauthorized", "invalid token")
	//
	return ctx, fmt.Errorf("not implemented")
}

// Accepts an arbitrary document as payload and sums the numbers contained
// within.
// The document can contain a variety of things: arrays [1,2,3,4], objects
// {"a":1, "b":2, "c":3}, numbers, and strings.
// The endpoint should find all of the numbers throughout the document and add
// them together.

// For example:
// * [1,2,3,4] and {"a":6,"b":4} both have a auth_sum of 10.
// * [[[2]]] and {"a":{"b":4},"c":-2} both have a auth_sum of 2.
// * {"a":[-1,1,"dark"]} and [-1,{"a":1, "b":"light"}] both have a auth_sum of
// 0.
// * [] and {} both have a auth_sum of 0.

// Protected with a valid JWT token, generated by the /auth endpoint, provided
// as a Bearer Authorization header.
// The response is the sum of all numbers in the document.
func (s *MathSrvc) Sum(ctx context.Context, p *gen_math.SumPayload) (res string, err error) {

	// no token - sanity check!
	if p.Token == "" {
		return "", goa.PermanentError("Unauthorized", "Invalid token")
	}

	// empty body
	if p.Doc == "" {
		return "", goa.PermanentError("MalformedPayload", "Empty body")
	}

	var doc interface{}
	e := json.Unmarshal([]byte(p.Doc), &doc)

	// invalid JSON
	if e != nil {
		return "", goa.PermanentError("MalformedPayload", "Malformed JSON: %s", e.Error())
	}

	// process JSON
	sum := ProcessJson(doc)

	return fmt.Sprint(sum), nil
}

// Accepts a sequence of numbers and multiplies them.
// If any of the arguments is not a valid number, it returns an error.

// Protected with a valid JWT token, generated by the /auth endpoint, provided
// as a Bearer Authorization header.
// The response is the multiplication of all numbers.
func (s *MathSrvc) Mul(ctx context.Context, p *gen_math.MulPayload) (res string, err error) {

	// no token - sanity check!
	if p.Token == "" {
		return "", goa.PermanentError("Unauthorized", "Invalid token")
	}

	// empty args -> return 0
	if len(p.Numbers) == 0 {
		return "0", nil
	}

	total := new(big.Float)
	temp := new(big.Float)
	for index, ns := range p.Numbers {
		_, success := temp.SetString(ns)
		// if error, break
		if !success {
			return "", goa.PermanentError("MalformedPayload", "Malformed number: %s", ns)
		}
		if index == 0 {
			total.Set(temp)
		} else {
			total = total.Mul(total, temp)
		}
	}

	return fmt.Sprint(total), nil
}

// Recursive method to generate a sum from the numbers in an arbitrary JSON document
// The generated number is formatted as a string, either as an integer or with fixed 5 decimals precision
func ProcessJson(doc interface{}) string {

	var sum float64 = 0

	processEntry(doc, &sum)

	// depending if integer result, format string with or without decimals
	if sum == math.Trunc(sum) {
		return fmt.Sprintf("%v", sum)
	} else {
		return fmt.Sprintf("%.5f", sum)
	}
}

func processEntry(e interface{}, sum *float64) {

	switch e.(type) {
	case float64:
		*sum += e.(float64)
	case map[string]interface{}:
		for k, v := range e.(map[string]interface{}) {
			processEntry(k, sum)
			processEntry(v, sum)
		}
	case []interface{}:
		for _, i := range e.([]interface{}) {
			processEntry(i, sum)
		}
	default:
		// ignore
	}

}